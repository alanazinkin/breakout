package breakout;

import javafx.animation.Timeline;
import javafx.scene.Group;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Rectangle;
import javafx.scene.shape.Shape;

import static breakout.Main.*;

// bouncer class inspired from bounce lab
public class Bouncer extends Circle {
    private Circle myBouncer;
    private int size;
    private double myXSpeed;
    private double myYSpeed;
    private int myXDirection;
    private int myYDirection;

    final static int SPACE = 2;
    final static int EXTRA_SPACE = 1;


    public Bouncer(double centerX, double centerY, int size, Color color, double myXSpeed,
                   double myYSpeed, int myXDirection, int myYDirection) {
        myBouncer = new Circle(centerX, centerY, size, color);
        this.myXSpeed = myXSpeed;
        this.myYSpeed = myYSpeed;
        this.myXDirection = myXDirection;
        this.myYDirection = myYDirection;
    }

    public void move(double elapsedTime) {
        myBouncer.setCenterX(myBouncer.getCenterX() + this.myXSpeed * this.myXDirection * elapsedTime);
        myBouncer.setCenterY(myBouncer.getCenterY() + this.myYSpeed * this.myYDirection * elapsedTime);
    }

    public void bounce(int screenSize, int bouncerSize) {
        if (myBouncer.getCenterX() >= screenSize - bouncerSize || myBouncer.getCenterX() <= 0 + bouncerSize) {
            myXDirection *= -1;
        }
        if (myBouncer.getCenterY() >= screenSize - bouncerSize || myBouncer.getCenterY() <= 0 + bouncerSize) {
            myYDirection *= -1;
        }
    }

    public void paddleIntersect(Rectangle paddle, Level myLevel) {
        Shape paddleIntersection = Shape.intersect(myBouncer, paddle);
        if (paddleIntersection.getBoundsInLocal().getWidth() != -1) {
            myYDirection *= -1;
            // specific paddle for level 3
            if (myLevel.getLevel() == 3) {
                setBouncerXDirectionPaddle(paddle);
            }
        }
    }

    private void setBouncerXDirectionPaddle(Rectangle paddle) {
        double ballCenterX = myBouncer.getCenterX();
        double paddleCenterX = paddle.getX() + paddle.getWidth() / 2;
        if (Math.abs(ballCenterX - paddleCenterX) < paddle.getWidth() * 0.2) {return;}
        // logical statement syntax generated by ChatGPT
        myXDirection = (ballCenterX < paddleCenterX) ? -1 : 1;
    }

    public void keepWithinFrame(int screenSize, int bouncerSize) {
        if (myBouncer.getCenterY() >= screenSize - bouncerSize - EXTRA_SPACE) {
            resetBouncer(screenSize, bouncerSize);
        }
    }

    public void resetBouncer(int screenSize, int bouncerSize) {
        myBouncer.setCenterX(screenSize / 2 - bouncerSize / 2);
        myBouncer.setCenterY(screenSize / 2 - bouncerSize / 2 + 60);
        myXDirection = 1;
        myYDirection = -1;
    }

    public void jumpAround(Group root, int bouncerSize, double elapsedTime) {
        bounce(SIZE, bouncerSize);
        move(elapsedTime);
        if (outTheBounds(SIZE, getMySize())) {
            root.getChildren().remove(getBouncer());
        }
    }


    public boolean outTheBounds(int screenSize, int bouncerSize) {
        return (myBouncer.getCenterY() >= screenSize - bouncerSize - SPACE);
    }

    public void setXDirection(int direction) {
        myXDirection = direction;
    }

    public void setYDirection(int direction) {
        myYDirection = direction;
    }

    public int getXDirection() {
        return this.myXDirection;
    }

    public int getYDirection() {
        return this.myYDirection;
    }

    public void setXSpeed(double speed) {
        myXSpeed = speed;
    }

    public void setYSpeed(double speed) {
        myYSpeed = speed;
    }

    public double getXSpeed() {
        return this.myXSpeed;
    }

    public double getYSpeed() {
        return this.myYSpeed;
    }

    public Circle getBouncer() {
        return this.myBouncer;
    }

    public int getMySize() {
        return size;
    }

}
